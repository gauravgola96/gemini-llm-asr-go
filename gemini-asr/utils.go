package gemini_asr

import (
	"bytes"
	"encoding/binary"
	"github.com/faiface/beep"
	"github.com/faiface/beep/wav"
	"github.com/go-audio/audio"
	"github.com/orcaman/writerseeker"
	"math"
)

// OutMessage represents the output from the Gemini model in our system.
// Text: Contains the predicted text generated by the model.
// Final: Indicates whether the prediction is the final output (true) or intermediate (false).
type OutMessage struct {
	Text      string
	Final     bool
	StartTime float64
	EndTime   float64
}

type SilveroOutMessage struct {
	data      *audio.IntBuffer
	StartTime float64
	EndTime   float64
}

type DetectedTimeQueue struct {
	q [][]float64
}

func (d *DetectedTimeQueue) Pop() ([]float64, bool) {
	if len(d.q) == 0 {
		return nil, false
	}
	item := d.q[0]
	d.q = d.q[1:]
	return item, true
}

func (d *DetectedTimeQueue) Push(i []float64) {
	d.q = append(d.q, i)
}

// AddRIFFHeader adds RIFF header to PCM byte array
func AddRIFFHeader(pcmData []byte, sampleRate, bitsPerSample, channels int) ([]byte, error) {
	// Calculate the sizes
	dataChunkSize := len(pcmData)
	riffChunkSize := 44 + dataChunkSize // 36 is the size of the RIFF/WAVE headers excluding the data
	byteRate := sampleRate * channels * bitsPerSample / 8
	blockAlign := channels * bitsPerSample / 8

	// Create a buffer to hold the header
	buf := new(bytes.Buffer)

	// Write the RIFF header
	err := binary.Write(buf, binary.LittleEndian, []byte("RIFF"))
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, uint32(riffChunkSize))
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, []byte("WAVE"))
	if err != nil {
		return nil, err
	}

	// Write the fmt subchunk
	err = binary.Write(buf, binary.LittleEndian, []byte("fmt "))
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, uint32(16)) // Subchunk1Size for PCM
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, uint16(1)) // AudioFormat (1 for PCM)
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, uint16(channels))
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, uint32(sampleRate))
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, uint32(byteRate))
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, uint16(blockAlign))
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, uint16(bitsPerSample))
	if err != nil {
		return nil, err
	}

	// Write the data subchunk
	err = binary.Write(buf, binary.LittleEndian, []byte("data"))
	if err != nil {
		return nil, err
	}
	err = binary.Write(buf, binary.LittleEndian, uint32(dataChunkSize))
	if err != nil {
		return nil, err
	}

	// Write the PCM data
	err = binary.Write(buf, binary.LittleEndian, pcmData)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

// ResampleAudio resamples pcm audio bytes to desired sample rate
func ResampleAudio(pcm []byte, sampleRate int) ([]byte, error) {
	s, format, err := wav.Decode(bytes.NewBuffer(pcm))
	if err != nil {
		return nil, err
	}
	format.NumChannels = 1
	resampler := beep.Resample(10, format.SampleRate, beep.SampleRate(sampleRate), s)
	output := &writerseeker.WriterSeeker{}
	err = wav.Encode(output, resampler, format)
	if err != nil {
		return nil, err
	}
	buf := new(bytes.Buffer)
	_, err = buf.ReadFrom(output.Reader())
	if err != nil {
		return nil, err
	}
	data := buf.Bytes()[44:]
	return data, nil
}

func ResampleInt16(input []int16, inputRate, outputRate int) []int16 {
	// Calculate the resampling ratio
	ratio := float64(inputRate) / float64(outputRate)

	// Calculate the length of the resampled output
	outputLength := int(float64(len(input)) / ratio)

	// Allocate a slice for the resampled output
	output := make([]int16, outputLength)

	// Perform linear interpolation for resampling
	for i := 0; i < outputLength-1; i++ {
		// Calculate the corresponding position in the input
		pos := float64(i) * ratio

		// Calculate the indices of the surrounding input samples
		indexBefore := int(pos)
		indexAfter := indexBefore + 1
		if indexAfter >= len(input) {
			indexAfter = len(input) - 1
		}

		// Calculate the fractional part of the position
		frac := pos - float64(indexBefore)

		// Linearly interpolate between the two surrounding input samples
		output[i] = int16((1-frac)*float64(input[indexBefore]) + frac*float64(input[indexAfter]))
	}

	// Handle the last sample explicitly to avoid index out of range
	output[outputLength-1] = input[len(input)-1]

	return output
}

func ConvertInt16ToInt(input []int16) []int {
	output := make([]int, len(input)) // Allocate a slice for the output
	for i, value := range input {
		output[i] = int(value) // Convert each int16 to int and assign it to the output slice
	}
	return output // Return the converted slice
}

// calculateRMS16 calculates the root mean square of the audio buffer for int16 samples.
func calculateRMS16(buffer []int16) float64 {
	var sumSquares float64
	for _, sample := range buffer {
		val := float64(sample) // Convert int16 to float64 for calculation
		sumSquares += val * val
	}
	meanSquares := sumSquares / float64(len(buffer))
	return math.Sqrt(meanSquares)
}
